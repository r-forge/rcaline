% \VignetteIndexEntry{Rcaline: Modeling traffic-related pollution with R and the CALINE3 dispersion model} 
% \VignetteDepends{Rcaline, sp, rgdal, spatstat, maptools}
% \VignetteKeyword{CALINE}
% \VignetteKeyword{CALINE3}

\documentclass[a4paper]{article}

\title{Rcaline: Modeling traffic-related pollution with R and the CALINE3 dispersion model}
\author{David Holstius}
\bibliographystyle{plain}

\begin{document}

\DefineVerbatimEnvironment{Sinput}{Verbatim} {xleftmargin=2em} \DefineVerbatimEnvironment{Soutput}{Verbatim}{xleftmargin=2em} \DefineVerbatimEnvironment{Scode}{Verbatim}{xleftmargin=2em} \fvset{listparameters={\setlength{\topsep}{0pt}}} \renewenvironment{Schunk}{\vspace{\topsep}}{\vspace{\topsep}}

<<echo=false>>=
options(width=60)
options(continue=" ")
options(SweaveHooks=list(fig=function() par(mar=c(5.1, 4.1, 1.1, 2.1))))
@

\maketitle

\newcommand{\code}[1]{\texttt{#1}}
\newcommand{\Rvar}[1]{\texttt{#1}}
\newcommand{\Rfunc}[1]{\texttt{#1}}
\newcommand{\Rpkg}[1]{\texttt{#1}}

<<label=load_workspace,echo=FALSE>>=
cache.fn <- 'WestOakland.RData'
if(file.exists(cache.fn))
	load(cache.fn)
@

<<echo=FALSE>>= 
options(
	width=60, 
	continue=" ", 
	SweaveHooks=list(fig=function() par(mar=c(5.1, 4.1, 1.1, 2.1)))
	)
@

\SweaveOpts{width=6,height=4}

\section{Introduction}

\Rpkg{Rcaline} provides an interface to the CALINE family of line-source atmospheric dispersion models \cite{benson1979caline3,benson1992review}. These steady-state, Gaussian dispersion models are used to predict aerosol concentrations downwind from mobile emission source(s) such as highway traffic.

\subsection{Features}

At the heart of \Rpkg{Rcaline} is a Fortran library, \Rpkg{libcaline}, that wraps original code from the CALINE3 implementation created by the California Department of Transportation (CALTRANS).\footnote{Support is planned for CALINE4 in a future release.} Given the same inputs, \Rpkg{libcaline} has been tested to produce identical outputs. However, \Rpkg{libcaline} removes significant limitations found in previous implementations of CALINE. For example, \Rpkg{libcaline} can be  be used to model an unlimited number of roadway links and an unlimited number of receptors, bound only by available memory and CPU resources.

By providing access to \Rpkg{libcaline} within the R environment, \Rpkg{Rcaline} also makes it much easier to run CALINE using contemporary data sources, such as ESRI shapefiles, as input. \Rpkg{Rcaline} also provides full machine-precision access to CALINE model results in a convenient format. Thus, it is easy to use basic R commands---or third-party R packages---to visualize, compare, and export model results. 

Finally, the R environment also provides useful scripting capabilities for automating large batches of model runs. For advanced users, it is possible to combine \Rpkg{Rcaline} with parallel computing tools, like the \Rpkg{multicore} package, to achieve significant speed gains in large model runs (e.g., ~4x on a modern 4-core machine, or 8x on an 8-core machine).

\subsection{Limitations}

The CALINE3 model is most appropriately used for modeling dispersion of carbon monoxide (CO) attributable to free-flow traffic with wind speeds greater than 1.0 m/s. As with any model, care should be exercised to ensure that the practical application is theoretically well founded. For more on the theoretical scope and limitations of the CALINE model family, including terrain and other considerations, see \cite{benson1992review}. 

\section{Example Usage}

In this section, we illustrate the use of \Rpkg{Rcaline} by applying it to highway data sourced from the OpenStreetMaps project \cite{haklay2008openstreetmap} (Figure~\ref{fig:highways}). There are three distinct steps: (1) preparing the input; (2) running the model; and (3) visualizing and/or exporting the output. Most of the work consists in preparing the input, and the reader is well advised to consult the CALINE User's Guide \cite{benson1979caline3} for additional detail.

\subsection{Preparing input}

\subsubsection{Reading from an ESRI shapefile}

Contemporary GIS data is often stored in the ESRI shapefile format. The \Rpkg{Rcaline} package includes an example of such a shapefile with highway data for West Oakland, California. 

<<label=locate_shpfile>>=
shpfile <- system.file('extdata', 'WestOakland', 'highways.shp', package='Rcaline')
@

We can read it into R by using the \Rfunc{readShapeSpatial} function from the \Rpkg{maptools} package, as follows:

<<label=read_shpfile,results=hide>>=
library(maptools)
highways <- readShapeSpatial(shpfile)
@

Note that \Rpkg{Rcaline} expects coordinates to be \textit{projected}: that is, to be given in meters, rather than in degrees latitude/longitude. If you need to (re)project your input shapefile, so that the coordinates are in meters, consult the documentation for the \Rpkg{sp} or \Rpkg{rgdal} packages.

<<label=construct_receptor_grid,include=FALSE,echo=FALSE>>=
library(sp)
receptor.grid <- sample.Spatial(highways, n=400, type='regular')
gridded(receptor.grid) <- TRUE
@

\begin{figure}[htb]
\begin{center}
<<label=plot_highways_and_receptor_grid,fig=TRUE,echo=FALSE>>=
plot(receptor.grid, pch=3, col='grey')
lines(highways)
@
\caption{Example highway geometry and receptor grid.}
\label{fig:highways}
\end{center}
\end{figure}

\subsubsection{Segmenting roadway geometry}

In preparation for a CALINE model run, we need to break the roadway geometry up into individual segments. This only needs to be done once; you can save the result for future use. 

<<label=break_up_links,results=hide>>=
library(spatstat)
segments <- lapply(highways@lines, function(x) as.psp(SpatialLines(list(x))))
segments <- do.call(rbind, lapply(segments, as.data.frame))
link.data <- merge(segments, highways, by.x='marks', by.y='row.names')
@

In this example, we're using the \Rfunc{as.psp} function from the \Rpkg{spatstat} package. The code above re-assigns to each segment the attributes associated with its parent polyline feature. If that's a bit confusing, don't worry. It allows us to retain attributes like traffic volume, link elevation, number of lanes, or other data that might have been present in the shapefile.

<<label=summarize_link_data,echo=FALSE>>=
summary(link.data)
@

\subsubsection{Imputing missing variables}

In this example, we're provided with an estimate of traffic volume: AADT (Annual Average Daily Traffic). However, we'll need to impute or assume default values for a few other variables. For example, the \code{LANES} variable, which supplies the number of lanes, has some NA (missing) values. One way to deal with that is to replace those with the median of the other values, as follows:

<<label=impute_missing_lanes>>=
link.data[is.na(link.data$LANES),'LANES'] <- median(link.data$LANES, na.rm=TRUE)
@

Using the number of lanes as a guide, we can calculate the highway width (a required input) using a rough estimate of 10 meters per lane.

<<label=estimate_link_width>>=
link.data <- transform(link.data, width=LANES*10.0)
@

Another required input is the height of each link above ground level, as well as a \textit{link classification}. Links can be classified as: At Grade (AG); Fill (FL); Bridge (BR); or Depressed (DP). This allows for a correction to be made depending on whether air can flow below as well as above the roadway link. It also allows for a correction for links built on raised ground or in a trench---in which case air will also flow differently.  

<<label=assume_at_grade>>=
link.data <- transform(link.data, height=0.0, classification='AG')
@

Lacking any other information, we'll assume all of the links are At Grade. (A more thorough analysis might perform a sensitivity test or include an adjustment factor to reflect the uncertainty introduced by this assumption.) 

Finally, we assign to each link an estimate of the \textit{flow}, or traffic volume (vehicles per hour), as well as an \textit{emissions factor}, given in grams per mile [per vehicle].

<<label=assign_flow_and_emissions>>=
link.data <- transform(link.data, flow = AADT / 24.0, emissions = 10.0)
@

Because we are interested in hourly estimates, we divide the average daily traffic by 24. We don't have an emission factor available, so we assume uniform emissions of 10 g /veh-mi. Precise estimates for emission factors can be obtained with the use of a sophisticated model, such as EMFAC \cite{emfac2007motor}, that takes into account prevailing weather conditions (temperature and humidity) as well as the composition of the local vehicle fleet. Fleet composition and emissions inventories are sometimes available on a statewide or regional basis; for example, the California Air Resources Board provides an emissions inventory at this level. \cite{carb2005estimated}

\subsubsection{Constructing a receptor grid}

Now that we have the traffic-related input prepared, we need to define a \textit{receptor grid}. These are the locations at which we will use the model to predict a pollutant concentration. A receptor grid can be constructed out of regularly spaced points, but it doesn't have to be. For example, receptor locations might be defined by census block points, or by a selection of coordinates stored in a CSV file. Or, they can be constructed on-the-fly, as follows:

<<>>=
<<construct_receptor_grid>>
@

The receptor grid is fully three-dimensional. A conventional approach is to assume a z-value of 1.8 meters above ground, which is about the same height as an average person's head. This helps if you are estimating a pollutant surface for exposure assessment purposes. 

\subsubsection{Providing meteorology}

CALINE3 requires four variables corresponding to the prevailing meteorology:
\begin{itemize}
\item wind bearing;
\item wind speed;
\item Pasquill stability class; and
\item mixing height.
\end{itemize}

Hourly values for these are sometimes available in the form of an ``ISC-ready'' input file, often with a .MET file extension. \Rpkg{Rcaline} provides a helpful function, \Rfunc{read.ISC}, for reading these files as input. (See ?read.ISC for more.) For this example, we'll just assume some reasonable values for a single hour. 

<<>>=
meteorology <- list(
	wind.bearing = 330.0,
	wind.speed = 1.5,
	stability.class = 4,
	mixing.height = 1000.0
)
@

If you are interested in computing annual averages, 8-hour maximum concentrations, etc., it's quite easy to use the scripting capabilities of R to process many different scenarios and summarize the results.

\subsection{Running the model}

Now that the roadway geometry, emissions, receptor locations, and prevailing meteorology have been established, we can run the model.

\subsubsection{Model parameters}

CALINE3 also requires several ``job parameters'', including:
\begin{itemize}
\item averaging time;
\item surface roughness;
\item pollutant settling velocity; and
\item pollutant deposition velocity.
\end{itemize}

We'll use some common values for averaging time (60 min) and surface roughness (100 cm). When modeling carbon monoxide, it's conventional to specify the settling velocity and deposition velocity as 0.0 m/s. For more on these parameters, including reasonable ranges and representative values, see \cite{benson1979caline3,benson1992review} or the documentation for \Rfunc{receptor\_totals}.

\subsubsection{Computing receptor totals}

The following code computes the predicted aerosol concentration, given the prevailing conditions and the parameters we've chosen.

<<label=compute_receptor_totals>>=
library(Rcaline)
if(!exists('predicted')) {
	predicted <- CALINE3.predict(receptor.grid, link.data, meteorology,
		averaging.time = 60.0, surface.roughness = 100.0)
}
@

<<label=save_workspace,echo=FALSE>>=
save.image(file=cache.fn)
@

\subsection{Visualizing the output}

As a quick check on the model output, it can be good to create a visualization. This most easily takes the form of a map. Since we have computed model results on a regular grid, it's fairly easy to construct such a map.

<<label=construct_receptor_grid_high_resolution,echo=FALSE>>=
receptor.grid <- sample.Spatial(highways, n=10000, type='regular')
gridded(receptor.grid) <- TRUE
@

\begin{figure}[htb]
\begin{center}
<<label=plot_heatmap,fig=TRUE,echo=FALSE>>=
cells <- SpatialPointsDataFrame(
	receptor.grid,
	data.frame(predicted))
gridded(cells) <- TRUE
print(spplot(cells, main='Predicted concentrations'))
@
\caption{Example heatmap at high resolution (10,000 receptors).}
\label{fig:heatmap}
\end{center}
\end{figure}

The map above was produced with a higher-resolution receptor grid than the one in Figure 1 (10,000 receptors vs 400 receptors). This is one approach to achieving high-resolution estimates of pollutant concentrations. Another would be to interpolate a lower-resolution receptor grid, using, for example, kriging or bicubic interpolation. Many R packages and functions are available to assist in this task!

\section{Acknowledgments}

The author wishes to thank Profs. Edmund Seto and Michael Jerrett of the UC Berkeley School of Public Health, Division of Environmental Health Sciences, as well as the UC Berkeley Center for Information Technology in the Interests of Society (CITRIS), for their generous support of the development of \Rpkg{Rcaline} and \Rpkg{libcaline}.

\bibliography{Rcaline}

\end{document}
